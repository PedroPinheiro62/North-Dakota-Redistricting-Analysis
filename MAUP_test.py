#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Mar 25

@author: Pedro Pinheiro

Lab 4: MAUP and data.  See details on Canvas page

Make sure to say where/when you got your data!
@author: Pedro Pinheiro

Citation: This Python script was based on the Python Script developed for Lab 3 and uses the shapefile
for PA generated by the PA_MAUP jupyter notebook on the same folder.

All data retrieved 03/25/24:
    https://redistrictingdatahub.org/dataset/pennsylvania-block-pl-94171-2020-by-table/
    https://redistrictingdatahub.org/dataset/vest-2020-pennsylvania-precinct-and-election-results/
    https://redistrictingdatahub.org/dataset/2022-pennslyvania-congressional-districts-approved-plan/

Data available at Google Drive:
https://drive.google.com/drive/folders/1085mysytFWZk2IDfG791PgdrA2BJjkrM?usp=sharing
"""


import geopandas as gpd
import matplotlib.pyplot as plt
from gerrychain import Graph, Partition, proposals, updaters, constraints, accept, MarkovChain, Election
from gerrychain.updaters import Tally
from functools import partial
import time
import random

random.seed(13579)

# Read Geodataframe from Shapefile.
gdf = gpd.read_file("./ND/ND.shp")

# Plot to check if shape is expected.
gdf.plot()
plt.show()

# Get Graph from geodataframe
nd_graph = Graph.from_geodataframe(gdf)

# Initial updaters to contain the cut_edges, district population and district latino population.
my_updaters = {
    "cut_edges": updaters.cut_edges,
    "population": Tally("TOTPOP", alias="population"),
    "latino population": Tally("HISP", alias = "latino population")
}

# Build presidential Election object.
elections = [
    Election("PRE20", {"Democratic": "PRES20D", "Republican": "PRES20R"})
]

# Add elections to updaters dict
election_updaters = {election.name: election for election in elections}
my_updaters.update(election_updaters)

# Create initial partion using updaters and the Congressional Districting ("SLDU_2021") as the assignment.
initial_partition = Partition(
    graph=nd_graph,
    assignment="SLDU_2021",
    updaters=my_updaters
)

# Get total population by summing districs population.
tot_pop = sum([initial_partition["population"][dist] for dist in initial_partition["population"].keys()])
print("Total Population: ", tot_pop)

# Get total population by summing districs population.
num_dist = len(initial_partition)
ideal_pop = tot_pop/num_dist
print("Number of Districts: ", num_dist)
print("Ideal District Population: ", ideal_pop)

pop_tolerance = 0.05
# Random walk proposal using recom
rw_proposal = partial(
    proposals.recom, # how you choose a next districting plan
    pop_col = "TOTPOP", # What data describes population? Column from original graph
    pop_target = ideal_pop, # What the target/ideal population is for each district 
    epsilon = pop_tolerance,
    node_repeats = 1 # number of times to repeat bipartition. Can increase if you get a BipartitionWarning
)

# Create population constraint using population percentage
population_constraint = constraints.within_percent_of_ideal_population(
    initial_partition=initial_partition,
    percent=pop_tolerance,
    pop_key="population"
)

# Create a short random walk using proposal and contraint to test.
total_steps = 10000
random_walk = MarkovChain(
    proposal = rw_proposal, 
    constraints = [population_constraint],
    accept = accept.always_accept, # Accept every proposed plan that meets the population constraints
    initial_state = initial_partition, 
    total_steps = total_steps
)

# Calculates the number of cut edges and democratic won districts for initial partition
print(f"Initial Partition (SLDU) - Cut Edges: {len(initial_partition["cut_edges"])}")
print(f"Initial Partition (SLDU) - Democratic Won Districts: {initial_partition["PRE20"].wins("Democratic")}")

# Calculates the number of latino-majority
num_maj_latin = 0
for population, latino_population in zip(initial_partition["population"].values(), initial_partition["latino population"].values()):
    latin_perc = latino_population / population
    if latin_perc >= 0.5:
        num_maj_latin += 1

print(f"Initial Partition (SLDU) - Latino-Majority Districts: {num_maj_latin}")


# Create ensemble to store results on each iteration of the random walk
cutedge_ensemble = []
latin_maj_ensemble = []
dem_won_ensemble = []

# Get start time
start_time = time.time()
print("Running Random Walk...")

# Run random walk
l = 1
for part in random_walk:
    print(l)
    l += 1
    # Add cutedges to cutedges ensemble
    cutedge_ensemble.append(len(part["cut_edges"]))
    
    # Calculate number of latino-majority and democratic won districts 
    # Add to ensembles
    num_maj_latin = 0
    for population, latino_population in zip(part["population"].values(), part["latino population"].values()):
        latin_perc = latino_population / population
        if latin_perc >= 0.5:
            num_maj_latin += 1

    latin_maj_ensemble.append(num_maj_latin)
    dem_won_ensemble.append(part["PRE20"].wins("Democratic"))

# Get end time
end_time = time.time()
print()
print("The time of execution of above program is :",
      (end_time-start_time)/60, "mins")

# Plot histograms side by side.
fig, axs = plt.subplots(1, 3, figsize=(15, 3))

# Plot cut edges histogram with dynamic range and bin size=25
axs[0].hist(cutedge_ensemble,
            bins=range(
                ((min(cutedge_ensemble) // 25) * 25),
                ((max(cutedge_ensemble) // 25) * 25 + 50),
                25
            ),
            align='left'
)
axs[0].set_title('Cut Edges')

# Plot latin majority histogram with dynamic range
axs[1].hist(latin_maj_ensemble,
            bins=range(min(latin_maj_ensemble), max(latin_maj_ensemble) + 5),
            align='left'
)
axs[1].set_title('Latin-Majority Districts')

# Plot democratic won histogram with dynamic range
axs[2].hist(dem_won_ensemble,
            bins=range(min(dem_won_ensemble), max(dem_won_ensemble) + 5),
            align='left'
)
axs[2].set_title('Democratic Won Districts')

plt.show()
